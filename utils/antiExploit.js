const logger = require('./logger');
const securityManager = require('./security');

/**
 * Anti-Exploit Protection System
 * Prevents common exploit patterns and gaming system abuse
 */

class AntiExploitManager {
    constructor() {
        this.suspiciousPatterns = new Map();
        this.userTransactions = new Map();
        this.maxTransactionValue = 1000000; // 1M coins max per transaction
        this.maxTransactionsPerHour = 100;
        this.suspiciousThreshold = 5;
        this.cleanupInterval = 3600000; // 1 hour
        
        // Start cleanup timer
        setInterval(() => this.cleanupOldData(), this.cleanupInterval);
    }

    /**
     * Validate economic transaction (coins, powers, etc.)
     * @param {string} userId - User ID
     * @param {string} transactionType - Type of transaction
     * @param {number} amount - Transaction amount
     * @param {object} context - Additional context
     * @returns {object} Validation result
     */
    validateTransaction(userId, transactionType, amount, context = {}) {
        try {
            // Basic validation
            if (!userId || !transactionType || typeof amount !== 'number') {
                return { valid: false, reason: 'Invalid transaction parameters' };
            }

            // Amount validation
            if (amount > this.maxTransactionValue) {
                this.flagSuspiciousActivity(userId, 'excessive_transaction', {
                    type: transactionType,
                    amount,
                    context
                });
                return { valid: false, reason: 'Transaction amount exceeds maximum limit' };
            }

            // Rate limiting
            const rateLimitResult = this.checkTransactionRateLimit(userId, transactionType);
            if (!rateLimitResult.allowed) {
                return { valid: false, reason: rateLimitResult.reason };
            }

            // Pattern detection
            const patternResult = this.detectSuspiciousPattern(userId, transactionType, amount, context);
            if (!patternResult.valid) {
                return { valid: false, reason: patternResult.reason };
            }

            // Record transaction
            this.recordTransaction(userId, transactionType, amount, context);

            return { valid: true };
        } catch (error) {
            logger.error('Error validating transaction', { userId, transactionType, amount, error: error.message });
            return { valid: false, reason: 'Transaction validation failed' };
        }
    }

    /**
     * Check transaction rate limiting
     * @param {string} userId - User ID
     * @param {string} transactionType - Transaction type
     * @returns {object} Rate limit result
     */
    checkTransactionRateLimit(userId, transactionType) {
        const now = Date.now();
        const hourAgo = now - 3600000; // 1 hour ago
        
        if (!this.userTransactions.has(userId)) {
            this.userTransactions.set(userId, []);
        }

        const userTransactions = this.userTransactions.get(userId);
        
        // Remove old transactions
        const recentTransactions = userTransactions.filter(t => t.timestamp > hourAgo);
        this.userTransactions.set(userId, recentTransactions);

        // Check rate limit
        if (recentTransactions.length >= this.maxTransactionsPerHour) {
            this.flagSuspiciousActivity(userId, 'rate_limit_exceeded', {
                type: transactionType,
                count: recentTransactions.length,
                timeframe: '1 hour'
            });
            
            return {
                allowed: false,
                reason: 'Transaction rate limit exceeded. Please wait before making more transactions.'
            };
        }

        return { allowed: true };
    }

    /**
     * Detect suspicious transaction patterns
     * @param {string} userId - User ID
     * @param {string} transactionType - Transaction type
     * @param {number} amount - Transaction amount
     * @param {object} context - Transaction context
     * @returns {object} Pattern detection result
     */
    detectSuspiciousPattern(userId, transactionType, amount, context) {
        const patterns = [
            this.detectRapidFireTransactions,
            this.detectAmountManipulation,
            this.detectDuplicationAttempts,
            this.detectTimingExploits,
            this.detectResourceDuplication
        ];

        for (const patternChecker of patterns) {
            const result = patternChecker.call(this, userId, transactionType, amount, context);
            if (!result.valid) {
                return result;
            }
        }

        return { valid: true };
    }

    /**
     * Detect rapid-fire transactions
     * @param {string} userId - User ID
     * @param {string} transactionType - Transaction type
     * @param {number} amount - Transaction amount
     * @param {object} context - Transaction context
     * @returns {object} Detection result
     */
    detectRapidFireTransactions(userId, transactionType, amount, context) {
        const now = Date.now();
        const shortWindow = 5000; // 5 seconds
        
        if (!this.userTransactions.has(userId)) {
            return { valid: true };
        }

        const userTransactions = this.userTransactions.get(userId);
        const recentTransactions = userTransactions.filter(t => 
            now - t.timestamp < shortWindow && t.type === transactionType
        );

        if (recentTransactions.length >= 5) {
            this.flagSuspiciousActivity(userId, 'rapid_fire_transactions', {
                type: transactionType,
                count: recentTransactions.length,
                timeframe: '5 seconds'
            });
            
            return {
                valid: false,
                reason: 'Too many rapid transactions detected. Please slow down.'
            };
        }

        return { valid: true };
    }

    /**
     * Detect amount manipulation attempts
     * @param {string} userId - User ID
     * @param {string} transactionType - Transaction type
     * @param {number} amount - Transaction amount
     * @param {object} context - Transaction context
     * @returns {object} Detection result
     */
    detectAmountManipulation(userId, transactionType, amount, context) {
        // Check for negative amounts in positive contexts
        if (['purchase', 'gacha', 'bet'].includes(transactionType) && amount < 0) {
            this.flagSuspiciousActivity(userId, 'negative_amount_exploit', {
                type: transactionType,
                amount,
                context
            });
            
            return {
                valid: false,
                reason: 'Invalid transaction amount detected.'
            };
        }

        // Check for impossibly large amounts
        if (amount > 1000000000) { // 1 billion
            this.flagSuspiciousActivity(userId, 'impossible_amount', {
                type: transactionType,
                amount,
                context
            });
            
            return {
                valid: false,
                reason: 'Transaction amount is unrealistic.'
            };
        }

        return { valid: true };
    }

    /**
     * Detect duplication attempts
     * @param {string} userId - User ID
     * @param {string} transactionType - Transaction type
     * @param {number} amount - Transaction amount
     * @param {object} context - Transaction context
     * @returns {object} Detection result
     */
    detectDuplicationAttempts(userId, transactionType, amount, context) {
        const now = Date.now();
        const duplicateWindow = 1000; // 1 second
        
        if (!this.userTransactions.has(userId)) {
            return { valid: true };
        }

        const userTransactions = this.userTransactions.get(userId);
        const duplicateTransaction = userTransactions.find(t => 
            now - t.timestamp < duplicateWindow &&
            t.type === transactionType &&
            t.amount === amount &&
            JSON.stringify(t.context) === JSON.stringify(context)
        );

        if (duplicateTransaction) {
            this.flagSuspiciousActivity(userId, 'duplicate_transaction', {
                type: transactionType,
                amount,
                originalTimestamp: duplicateTransaction.timestamp,
                context
            });
            
            return {
                valid: false,
                reason: 'Duplicate transaction detected. Please wait before trying again.'
            };
        }

        return { valid: true };
    }

    /**
     * Detect timing exploits
     * @param {string} userId - User ID
     * @param {string} transactionType - Transaction type
     * @param {number} amount - Transaction amount
     * @param {object} context - Transaction context
     * @returns {object} Detection result
     */
    detectTimingExploits(userId, transactionType, amount, context) {
        // Check for commands executed too quickly after cooldown
        if (context.afterCooldown && context.cooldownEndTime) {
            const timeSinceCooldown = Date.now() - context.cooldownEndTime;
            if (timeSinceCooldown < 100) { // Less than 100ms
                this.flagSuspiciousActivity(userId, 'timing_exploit', {
                    type: transactionType,
                    timeSinceCooldown,
                    context
                });
                
                return {
                    valid: false,
                    reason: 'Command executed too quickly after cooldown.'
                };
            }
        }

        return { valid: true };
    }

    /**
     * Detect resource duplication attempts
     * @param {string} userId - User ID
     * @param {string} transactionType - Transaction type
     * @param {number} amount - Transaction amount
     * @param {object} context - Transaction context
     * @returns {object} Detection result
     */
    detectResourceDuplication(userId, transactionType, amount, context) {
        // Check for impossible resource gains
        if (transactionType === 'coins_gained' && amount > 100000) {
            this.flagSuspiciousActivity(userId, 'impossible_resource_gain', {
                type: transactionType,
                amount,
                context
            });
            
            return {
                valid: false,
                reason: 'Resource gain amount is unrealistic.'
            };
        }

        return { valid: true };
    }

    /**
     * Record transaction for pattern analysis
     * @param {string} userId - User ID
     * @param {string} transactionType - Transaction type
     * @param {number} amount - Transaction amount
     * @param {object} context - Transaction context
     */
    recordTransaction(userId, transactionType, amount, context) {
        if (!this.userTransactions.has(userId)) {
            this.userTransactions.set(userId, []);
        }

        const userTransactions = this.userTransactions.get(userId);
        userTransactions.push({
            timestamp: Date.now(),
            type: transactionType,
            amount,
            context
        });

        // Keep only last 200 transactions per user
        if (userTransactions.length > 200) {
            userTransactions.shift();
        }
    }

    /**
     * Flag suspicious activity
     * @param {string} userId - User ID
     * @param {string} activityType - Type of suspicious activity
     * @param {object} details - Activity details
     */
    flagSuspiciousActivity(userId, activityType, details) {
        const now = Date.now();
        
        if (!this.suspiciousPatterns.has(userId)) {
            this.suspiciousPatterns.set(userId, {
                count: 0,
                activities: []
            });
        }

        const userPattern = this.suspiciousPatterns.get(userId);
        userPattern.count++;
        userPattern.activities.push({
            timestamp: now,
            type: activityType,
            details
        });

        // Keep only last 50 activities
        if (userPattern.activities.length > 50) {
            userPattern.activities.shift();
        }

        logger.warn(`Suspicious activity detected`, {
            userId,
            activityType,
            details,
            totalCount: userPattern.count,
            timestamp: new Date(now).toISOString()
        });

        // Take action if threshold exceeded
        if (userPattern.count >= this.suspiciousThreshold) {
            this.handleSuspiciousUser(userId, userPattern);
        }
    }

    /**
     * Handle user with suspicious activity
     * @param {string} userId - User ID
     * @param {object} pattern - Suspicious pattern data
     */
    handleSuspiciousUser(userId, pattern) {
        logger.error(`User flagged for suspicious activity`, {
            userId,
            totalViolations: pattern.count,
            recentActivities: pattern.activities.slice(-10), // Last 10 activities
            timestamp: new Date().toISOString()
        });

        // In production, you might want to:
        // - Temporarily restrict user actions
        // - Alert administrators
        // - Require additional verification
        // - Log to security monitoring system
    }

    /**
     * Check if user has excessive suspicious activity
     * @param {string} userId - User ID
     * @returns {object} Suspicious activity status
     */
    isUserSuspicious(userId) {
        if (!this.suspiciousPatterns.has(userId)) {
            return { suspicious: false, count: 0 };
        }

        const pattern = this.suspiciousPatterns.get(userId);
        const recentActivities = pattern.activities.filter(
            activity => Date.now() - activity.timestamp < 3600000 // Last hour
        );

        return {
            suspicious: recentActivities.length >= this.suspiciousThreshold,
            count: pattern.count,
            recentCount: recentActivities.length,
            activities: recentActivities
        };
    }

    /**
     * Clean up old data
     */
    cleanupOldData() {
        const now = Date.now();
        const oldDataThreshold = 86400000; // 24 hours

        // Clean up user transactions
        for (const [userId, transactions] of this.userTransactions.entries()) {
            const recentTransactions = transactions.filter(
                t => now - t.timestamp < oldDataThreshold
            );
            
            if (recentTransactions.length === 0) {
                this.userTransactions.delete(userId);
            } else {
                this.userTransactions.set(userId, recentTransactions);
            }
        }

        // Clean up suspicious patterns
        for (const [userId, pattern] of this.suspiciousPatterns.entries()) {
            const recentActivities = pattern.activities.filter(
                activity => now - activity.timestamp < oldDataThreshold
            );
            
            if (recentActivities.length === 0) {
                this.suspiciousPatterns.delete(userId);
            } else {
                pattern.activities = recentActivities;
                pattern.count = recentActivities.length;
            }
        }

        logger.info('Anti-exploit data cleanup completed', {
            remainingUsers: this.userTransactions.size,
            suspiciousUsers: this.suspiciousPatterns.size
        });
    }

    /**
     * Get user transaction history
     * @param {string} userId - User ID
     * @param {number} limit - Maximum number of transactions to return
     * @returns {Array} Transaction history
     */
    getUserTransactionHistory(userId, limit = 50) {
        if (!this.userTransactions.has(userId)) {
            return [];
        }

        const transactions = this.userTransactions.get(userId);
        return transactions.slice(-limit).map(t => ({
            ...t,
            timestamp: new Date(t.timestamp).toISOString()
        }));
    }

    /**
     * Get system statistics
     * @returns {object} System statistics
     */
    getSystemStats() {
        const totalUsers = this.userTransactions.size;
        const totalTransactions = Array.from(this.userTransactions.values())
            .reduce((sum, transactions) => sum + transactions.length, 0);
        
        const suspiciousUsers = this.suspiciousPatterns.size;
        const totalSuspiciousActivities = Array.from(this.suspiciousPatterns.values())
            .reduce((sum, pattern) => sum + pattern.count, 0);

        return {
            totalUsers,
            totalTransactions,
            suspiciousUsers,
            totalSuspiciousActivities,
            timestamp: new Date().toISOString()
        };
    }
}

// Create singleton instance
const antiExploitManager = new AntiExploitManager();

module.exports = antiExploitManager;